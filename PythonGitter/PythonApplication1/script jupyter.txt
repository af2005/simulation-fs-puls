#!/usr/bin/env python
# -*- coding: utf-8; -*-
#
# Copyright (C) 2017 Bernd Lienau, Simon Jung, Alexander Franke

import math
import cmath
import numpy as np

from numpy import sin as sin
from numpy import cos as cos
from numpy import tan as tan
from numpy import arcsin as arcsin
from numpy import arccos as arccos
from numpy import arctan as arctan
from numpy import exp as exp

from numpy.fft import fft as fft
from numpy.fft import fft2 as fft2
from numpy import pi as pi


import csv
import pandas as pd
import scipy
from scipy import integrate as integrate


import matplotlib.pyplot as plt
import argparse

#main() wird automatisch aufgerufen
def main():

    # Variablen auf SI Einheiten bringen. 
    wl = 780 * 1e-9
    zs = 350 * 1e-2
    nx = 1
    ny = 2
    ax = 3  * 1e-6
    ay = 3  * 1e-6
    dx = 10  * 1e-6
    dy = 10  * 1e-6
    k  = 2 * np.pi / wl

    comparefft(nx,ny,ax,ay,dx,dy,wl,zs)
    #spalt3d(nx,ny,ax,ay,dx,dy,wl,zs)


    #__________________________________________________________________
    # Ende der main()


####__________________________________________________________________
#### Hilfsvariablen/funktionen. Muss leider so. Python ist etwas eigen 
#### mit seinen globalen Variable. Im Prinzip existieren sie nicht. 
#### Jetzt kann man überall darauf zugreifen mit z.B. c(). 
#### Die Wellenlänge müssen wir aber leider mitschleppen.
####__________________________________________________________________

def	k(wl):
    # Kreiswellenzahl
    return 2 * np.pi / wl 
def w(wl):
    # Kreisfrequenz Omega
    return c() * k(wl) 
def f(wl):
    # Frequenz
    return c() / wl 
def c():
    return float(299792458) # m/s

def sinc(x):
    return sin(x)/x

def i():
    return complex(0,1)

def dirac(x,mu):
    #ich weiß noch nicht wie es am besten ist hier dran zu gehen. 
    #Das hier ist eine gängige Approximation für mu->infinity
    return (np.abs(mu)/((pi)**0.5)) * exp(-(x*mu)**2)

#sollte keinen Unterschied fuer uns machen, da das Ergebnis immer real ist (zumindest fuer n Spalte)
def complex_int(func, a, b, **kwargs):
    def real_func(x):
        return scipy.real(func(x))
    def imag_func(x):
        return scipy.imag(func(x))
    real_integral = integrate.quad(real_func, a, b, **kwargs)
    imag_integral = integrate.quad(imag_func, a, b, **kwargs)
    return (real_integral[0] + i()*imag_integral[0])


####__________________________________________________________________
#### Berechnungsfunktionen mittels Fouriertransformation 
####__________________________________________________________________ 

def fourierNspalt(xArray,yArray,nx,ny,ax,ay,dx,dy,wl,zs):  ##funktioniert
    #Diese Funktion dient nur dafuer nicht mit einem Array an x Werten arbeiten zu muessen, was 
    #beim Integrieren bzw bei der fft schief geht.
    subArrayX= []
    subArrayY= []
    
    for x in xArray:
        subArrayX.append((float(fourierNspaltIntegrate(x,nx,ax,dx,wl,zs))))
    for y in yArray:
        subArrayY.append((float(fourierNspaltIntegrate(y,ny,ay,dy,wl,zs))))
        
    XX, YY = np.meshgrid(np.array(subArrayX),np.array(subArrayY))
    Ztmp=XX*YY

    return Ztmp

    
def fourierNspaltWithWholeTransmissionFunction(xArray,yArray,nx,ny,ax,ay,dx,dy,wl,zs): ##gibt 1D richtiges Ergebnis
    ## bietet die Möglichkeit in 'fourierNspaltIntegrateWithWholeTransmissionFunction(x,nx,ax,dx,wl,zs)' eine
    ## beliebige Funktion für das Gitter einzusetzen
    
    #Diese Funktion dient nur dafuer nicht mit einem Array an x Werten arbeiten zu muessen, was 
    #beim Integrieren bzw bei der fft schief geht.
    subArrayX= []
    subArrayY= []
    
    for x in xArray:
        subArrayX.append(float(fourierNspaltIntegrateWithWholeTransmissionFunction(x,nx,ax,dx,wl,zs)))
    for y in yArray:
        subArrayY.append(float(fourierNspaltIntegrateWithWholeTransmissionFunction(y,ny,ay,dy,wl,zs)))

    XX, YY = np.meshgrid(np.array(subArrayX),np.array(subArrayY))
    Ztmp=XX*YY
    
    return Ztmp
    
def fourierNspaltIntegrateWithWholeTransmissionFunction(x,n,a,d,wl,zs):
    # Fouriertransformierte von Transmission_Gitter
    
    ## bietet die Möglichkeit eine beliebige Funktion für das Gitter in 'Transmission_n_Spalte(y,n,a,d)' einzusetzen
    
    u = k(wl)*sin(arctan(x/zs))
    #lambda x sagt python nur dass das die Variable ist und nach der integriert werden muss
    f = lambda y:  Transmission_n_Spalte(y,n,a,d)*exp(-i()*u*y) 

    integral = complex_int(f,-(n-1)*d/2-a,(n-1)*d/2+a)
    #scipy.real koennte man weg lassen, da korrekterweise der imaginaer Teil immer null ist. Aber damit
    #matplot keine Warnung ausgibt, schmeissen wir den img Teil hier weg.
    integral =  scipy.real(np.square(np.multiply(n,integral)))
    return integral


def fourierNspaltIntegrate(x,n,a,d,wl,zs):
    # Fouriertransformierte von Transmission_Einzelspalt
    # Siehe Glg 29 im Theory doc.pdf
    # https://en.wikipedia.org/wiki/Dirac_delta_function#Translation folgend
    # ist f(t) gefaltet mit dirac(t-T) ist gleich f(t-T)
    # außerdem gilt distributivität (a+b) (*) c = a(*)c + b(*)c
    # für den Doppelspalt bzw. n-Spalt haben wir also
    u = k(wl)*sin(arctan(x/zs))
    #lambda x sagt python nur dass das die Variable ist und nach der integriert werden muss
    f = lambda y:  Transmission_Einzelspalt(y,a) *exp(-i()*u*y) 
    r = 0
    #Fuehre einen Multiplikationsfaktor ein. Dieser Faktor entspricht dem aus Glg 34 ff.
    #Fuer jeden Spalt finden wir den Mittelpunkt und addieren entsprechend die 
    #Fouriertransformation dieser Dirac funktion. Die Breite a dieser ganzen Spalte ist durch
    #die Funktion f mit der Transmission eines Spaltes festgelegt.
    #Hier ist also noch eine Verbesserung notwendig, die uns ermoeglicht unterschiedlich breite
    #Spalte einzubauen.

    mittelpunkteDerLoecher = Transmission_Mittelpunkte(n,d)
    #print(mittelpunkteDerLoecher)
    for pkt in mittelpunkteDerLoecher:
        r = r + (exp(i()*u*pkt))

    if(n==1):
        r = 1
    integral = complex_int(f,-a,a)
    #scipy.real koennte man weg lassen, da korrekterweise der imaginaer Teil immer null ist. Aber damit
    #matplot keine Warnung ausgibt, schmeissen wir den img Teil hier weg.
    integral =  scipy.real(np.square(n * np.multiply(integral,r)))
    return integral

####__________________________________________________________________
#### Transmissionsfunktion verschiedener Objekte
####__________________________________________________________________

def Transmission_Einzelspalt(x,a):
    if math.fabs(x) < a/2:
        return 1
    else:
        return 0

def Transmission_Lochblende(rho,R):
    #einzelnes Loch mit Radius R
    #Verwende Polarkoordinaten rho,theta 
    if (rho < R):
        return 1
    else: 
        return 0
def Transmission_Mittelpunkte(n,d):
    mittelpunkte = []
    i = 1
    if (n%2) == 1:
        mittelpunkte.append(0)

    while i<=n/2:
        if (n % 2) == 0:
            mittelpunkte.append(d*(2*i-1)/2)
            mittelpunkte.append(-d*(2*i-1)/2)
        else:
            mittelpunkte.append((i)*d)
            mittelpunkte.append(-(i)*d)

        i =i+1

    return mittelpunkte

def Transmission_n_Spalte(x,n,a,d):

    gesamttransmission = 0.
    i = 1

    if (n % 2) == 1:
        gesamttransmission = Transmission_Einzelspalt(x,a)

    while i<=n/2:
        if (n % 2) == 0:
            gesamttransmission += Transmission_Einzelspalt(x-d*(2*i-1)/2,a) + Transmission_Einzelspalt (x+d*(2*i-1)/2,a)
        else:
            gesamttransmission += Transmission_Einzelspalt(x-d*i,a) + Transmission_Einzelspalt(x+d*i,a)
        i =i+1


    return gesamttransmission

def Transmission_Gitter(x,y,n,a,d):
    return Transmission_n_Spalte(x,n,a,d) * Transmission_n_Spalte(y,n,a,d)

####__________________________________________________________________
#### Intensitätsverteilungen für verschiedene Objekte. Ich weiß nicht ob
#### wir das am Ende so machen können. Für einen Einzelspalt geht es
####__________________________________________________________________


def interferenz_einzelspalt_manuell(X,a,wl,zs):

    alphax = arctan(X/zs)
    return (((a*sinc(0.5*a*k(wl)*sin(alphax))))**2)

def interferenz_Nspalt_manuell(X,n,a,d,wl,zs):
    alphax = arctan(X/zs)
    #alphay = arctan(Y/zs)
    return ((n*sin(pi*n*d/wl*sin(alphax))/(sin(pi*d/wl*sin(alphax))) * a * sinc(pi*a/wl*sin(alphax)))**2)


####__________________________________________________________________
#### Hauptfunktionen für n Spalte, Gitter, Gitter mit Fehlstelle etc..
#### Aufzurufen aus der main()
####__________________________________________________________________




def spalt3d(nx,ny,ax,ay,dx,dy,wl,zs):
    # n  : Anzahl der Spalte
    # a  : Größe der Spalte
    # d  : Abstand (egal für Einzelspalt)
    
    x1  = np.arange(-3., 3., 0.005)
    y1  = np.arange(-3., 3., 0.005)

    X,Y = np.meshgrid(x1, y1)
    #Z = fourierNspaltWithWholeTransmissionFunction(x1,y1,nx,ny,ax,ay,dx,dy,wl,zs)
    Z = fourierNspalt(x1,y1,nx,ny,ax,ay,dx,dy,wl,zs)

    h = plt.contour(X,Y,Z,levels = np.linspace(np.min(Z), np.max(Z), 100))
    plt.show()

def comparefft(nx,ny,ax,ay,dx,dy,wl,zs):
    # n  : Anzahl der Spalte
    # a  : Größe der Spalte
    # d  : Abstand (egal für Einzelspalt)
    
    x1  = np.arange(-3., 3., 0.005)
    y1  = np.arange(-3., 3., 0.005)
    
    X,Y = np.meshgrid(x1, y1)

    z1 = fourierNspaltWithWholeTransmissionFunction(x1,y1,nx,ny,ax,ay,dx,dy,wl,zs)
    z2 = fourierNspalt(x1,y1,nx,ny,ax,ay,dx,dy,wl,zs)
    
    X_man=[]
    Y_man=[]
    for x in x1:
        X_man.append(interferenz_Nspalt_manuell(x,nx,ax,dx,wl,zs))
    for y in y1:
        Y_man.append(interferenz_Nspalt_manuell(y,ny,ay,dy,wl,zs))
    
    X_grid_man,Y_grid_man = np.meshgrid(X_man, Y_man)
    
    z3=X_grid_man*Y_grid_man
    
    fig, ax = plt.subplots(nrows=1, ncols=3)
    
    plt.subplot(1,3,1)
    f = plt.contour(X,Y,z1,levels = np.linspace(np.min(z1), np.max(z1), 100))
    
    plt.subplot(1,3,2)
    g = plt.contour(X,Y,z2,levels = np.linspace(np.min(z2), np.max(z2), 100))
    
    plt.subplot(1,3,3)
    h = plt.contour(X,Y,z3,levels = np.linspace(np.min(z3), np.max(z3), 100))
        
    plt.show()
    
#geht nach verändertem return value von fourierNspalt nicht mehr
#def spalt2d(n,a,d,h,wl,zs):
#    # n  : Anzahl der Spalte
#    # a  : Größe der Spalte
#    # d  : Abstand (egal für Einzelspalt)
#    # h  : Hoehe des Spaltes (überlicherweise unendlich)
#    t1 = np.arange(-3., 3., 0.005)
#    t2 = t1
#    plt.figure(1)
#    plt.subplot(211)
#    #plt.plot(t1,fourierEinzelspalt(arcsin(t1/zs),a,wl,lowerrange,upperrange) , 'r--')
#    #(xArray,a,wl,n,d,zs)
#    plt.plot(t1,fourierNspalt(t1,a,h,wl,n,d,zs) , 'r-')
#    plt.subplot(212)
#    plt.plot(t2,interferenz_Nspalt_manuell(t2,a,d,wl,zs,n),'b.')
#    plt.show()


def gitter(a,wl,zs):
    print('nothing here')

def gitterMitFehler(a,wl,zs,fehlerarray):
    print('nothing here')


if __name__ == "__main__":
    main()





